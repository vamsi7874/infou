{"version":3,"file":"fieldUtils.mjs","sources":["../../../../admin/src/preview/utils/fieldUtils.ts"],"sourcesContent":["import { type FieldContentSourceMap } from '@strapi/admin/strapi-admin';\n\nimport type { PREVIEW_ERROR_MESSAGES } from './constants';\nimport type { PreviewContextValue } from '../pages/Preview';\nimport type { Modules, Schema, Struct, UID } from '@strapi/types';\n\ntype PreviewErrorMessage = keyof typeof PREVIEW_ERROR_MESSAGES;\n\n// Generic error class for preview field operations\nexport class PreviewFieldError extends Error {\n  public readonly messageKey: PreviewErrorMessage;\n\n  constructor(messageKey: PreviewErrorMessage) {\n    super(messageKey);\n    this.name = 'PreviewFieldError';\n    this.messageKey = messageKey;\n  }\n}\n\ntype PathPart = { name: string; index?: number };\n\n// Helper function to parse path with array indices and return clean attribute names\nexport const parsePathWithIndices = (path: string): PathPart[] => {\n  // Split by dots, then parse array indices from each part. For example:\n  // input \"components.4.field.relations.2.name\"\n  // output [{name: \"components\", index: 4}, {name: \"field\"}, {name: \"relations\", index: 2}, {name: \"name\"}]\n  return path\n    .split('.')\n    .map((part) => {\n      const numericIndex = parseInt(part, 10);\n      if (!isNaN(numericIndex) && part === numericIndex.toString()) {\n        // This part is a pure numeric index, return it as an index for the previous part\n        return { name: '', index: numericIndex };\n      }\n      return { name: part };\n    })\n    .reduce((acc: PathPart[], part) => {\n      if (part.name === '' && part.index !== undefined) {\n        // This is an index, attach it to the previous part\n        if (acc.length > 0) {\n          acc[acc.length - 1].index = part.index;\n        }\n      } else {\n        acc.push(part);\n      }\n      return acc;\n    }, []);\n};\n\nexport function getAttributeSchemaFromPath({\n  path,\n  schema,\n  components,\n  document,\n}: {\n  path: string;\n  schema: PreviewContextValue['schema'] | PreviewContextValue['components'][string];\n  components: PreviewContextValue['components'];\n  document: Modules.Documents.AnyDocument;\n}): Schema.Attribute.AnyAttribute {\n  /**\n   * Create the function that will be recursively called.\n   * We don't do recursion on getAttributeSchemaFromPath itself because:\n   * - it takes a path string, not the parsed array that's better for recursion\n   * - even when several levels deep, we still need access to the root schema and components\n   */\n  const visitor = (\n    currentPathParts: PathPart[],\n    currentAttributes: Schema.Attributes,\n    currentData: any\n  ): Schema.Attribute.AnyAttribute => {\n    const [currentPart, ...remainingParts] = currentPathParts;\n\n    // Get the data and schema for the current path\n    const currentAttribute = currentAttributes[currentPart.name];\n\n    if (!currentAttribute) {\n      throw new PreviewFieldError('INVALID_FIELD_PATH');\n    }\n\n    if (currentAttribute.type === 'relation') {\n      throw new PreviewFieldError('RELATIONS_NOT_HANDLED');\n    }\n\n    if (currentAttribute.type === 'component') {\n      const componentAttributes = components[currentAttribute.component].attributes;\n      if (currentAttribute.repeatable) {\n        // We must have the index, otherwise we don't know what data to use\n        if (currentPart.index === undefined) {\n          throw new PreviewFieldError('INVALID_FIELD_PATH');\n        }\n        return visitor(\n          remainingParts,\n          componentAttributes,\n          currentData[currentPart.name][currentPart.index]\n        );\n      }\n\n      // Non repeatable component\n      return visitor(remainingParts, componentAttributes, currentData[currentPart.name]);\n    }\n\n    if (currentAttribute.type === 'dynamiczone') {\n      // We must have the index, otherwise we don't know what component we're dealing with\n      if (currentPart.index === undefined) {\n        throw new PreviewFieldError('INVALID_FIELD_PATH');\n      }\n\n      const componentData = currentData[currentPart.name][currentPart.index];\n      const componentAttributes = components[componentData.__component].attributes;\n      return visitor(remainingParts, componentAttributes, componentData);\n    }\n\n    // Plain regular field. It ends the recursion\n    return currentAttributes[currentPart.name];\n  };\n\n  return visitor(parsePathWithIndices(path), schema.attributes, document);\n}\n\nexport function parseFieldMetaData(strapiSource: string): FieldContentSourceMap | null {\n  const searchParams = new URLSearchParams(strapiSource);\n  const path = searchParams.get('path');\n  const type = searchParams.get('type');\n  const documentId = searchParams.get('documentId');\n  const locale = searchParams.get('locale');\n  const model = searchParams.get('model');\n  const kind = searchParams.get('kind');\n\n  if (!path || !type || !documentId || !model) {\n    return null;\n  }\n\n  return {\n    path,\n    type: type as Schema.Attribute.AnyAttribute['type'],\n    documentId,\n    locale: locale ?? null,\n    model: model as UID.Schema | undefined,\n    kind: kind ? (kind as Struct.ContentTypeKind) : undefined,\n  };\n}\n"],"names":["PreviewFieldError","Error","constructor","messageKey","name","parsePathWithIndices","path","split","map","part","numericIndex","parseInt","isNaN","toString","index","reduce","acc","undefined","length","push","getAttributeSchemaFromPath","schema","components","document","visitor","currentPathParts","currentAttributes","currentData","currentPart","remainingParts","currentAttribute","type","componentAttributes","component","attributes","repeatable","componentData","__component","parseFieldMetaData","strapiSource","searchParams","URLSearchParams","get","documentId","locale","model","kind"],"mappings":"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"}