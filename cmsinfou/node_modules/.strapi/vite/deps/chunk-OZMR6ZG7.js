import {
  useTypedDispatch,
  useTypedSelector
} from "./chunk-SQAPSDHR.js";
import {
  adminApi,
  login,
  logout,
  require_lib,
  setLocale
} from "./chunk-OP4OIIKW.js";
import {
  createContext
} from "./chunk-CQG5XAX6.js";
import {
  useLocation,
  useNavigate
} from "./chunk-MEXSUURY.js";
import {
  require_jsx_runtime
} from "./chunk-YHVPSBF3.js";
import {
  require_react
} from "./chunk-3ZCHZDHB.js";
import {
  __toESM
} from "./chunk-PLDDJCW6.js";

// node_modules/@strapi/admin/dist/admin/admin/src/features/StrapiApp.mjs
var [StrapiAppProvider, useStrapiApp] = createContext("StrapiApp");

// node_modules/@strapi/admin/dist/admin/admin/src/hooks/useQueryParams.mjs
var import_react = __toESM(require_react(), 1);
var import_qs = __toESM(require_lib(), 1);
var useSearch = () => {
  const { search } = useLocation();
  return (0, import_react.useMemo)(() => search, [
    search
  ]);
};
var useQueryParams = (initialParams) => {
  const search = useSearch();
  const navigate = useNavigate();
  const query = (0, import_react.useMemo)(() => {
    const searchQuery = search.startsWith("?") ? search.slice(1) : search;
    if (!search && initialParams) {
      return initialParams;
    }
    return {
      ...initialParams,
      ...(0, import_qs.parse)(searchQuery)
    };
  }, [
    search,
    initialParams
  ]);
  const setQuery = (0, import_react.useCallback)((nextParams, method = "push", replace = false) => {
    let nextQuery = {
      ...query
    };
    if (method === "remove") {
      Object.keys(nextParams).forEach((key) => {
        if (Object.prototype.hasOwnProperty.call(nextQuery, key)) {
          delete nextQuery[key];
        }
      });
    } else {
      nextQuery = {
        ...query,
        ...nextParams
      };
    }
    navigate({
      search: (0, import_qs.stringify)(nextQuery, {
        encode: false
      })
    }, {
      replace
    });
  }, [
    navigate,
    query
  ]);
  return [
    {
      query,
      rawQuery: search
    },
    setQuery
  ];
};

// node_modules/@strapi/admin/dist/admin/admin/src/services/auth.mjs
var authService = adminApi.enhanceEndpoints({
  addTagTypes: [
    "User",
    "Me",
    "ProvidersOptions"
  ]
}).injectEndpoints({
  endpoints: (builder) => ({
    /**
    * ME
    */
    getMe: builder.query({
      query: () => ({
        method: "GET",
        url: "/admin/users/me"
      }),
      transformResponse(res) {
        return res.data;
      },
      providesTags: (res) => res ? [
        "Me",
        {
          type: "User",
          id: res.id
        }
      ] : [
        "Me"
      ]
    }),
    getMyPermissions: builder.query({
      query: () => ({
        method: "GET",
        url: "/admin/users/me/permissions"
      }),
      transformResponse(res) {
        return res.data;
      }
    }),
    updateMe: builder.mutation({
      query: (body) => ({
        method: "PUT",
        url: "/admin/users/me",
        data: body
      }),
      transformResponse(res) {
        return res.data;
      },
      invalidatesTags: [
        "Me"
      ]
    }),
    /**
    * Permissions
    */
    checkPermissions: builder.query({
      query: (permissions) => ({
        method: "POST",
        url: "/admin/permissions/check",
        data: permissions
      })
    }),
    /**
    * Auth methods
    */
    login: builder.mutation({
      query: (body) => ({
        method: "POST",
        url: "/admin/login",
        data: body
      }),
      transformResponse(res) {
        return res.data;
      },
      invalidatesTags: [
        "Me"
      ]
    }),
    logout: builder.mutation({
      query: (body) => ({
        method: "POST",
        url: "/admin/logout",
        data: body
      })
    }),
    resetPassword: builder.mutation({
      query: (body) => ({
        method: "POST",
        url: "/admin/reset-password",
        data: body
      }),
      transformResponse(res) {
        return res.data;
      }
    }),
    accessTokenExchange: builder.mutation({
      query: (body) => ({
        method: "POST",
        url: "/admin/access-token",
        data: body
      }),
      transformResponse(res) {
        return res.data;
      }
    }),
    getRegistrationInfo: builder.query({
      query: (registrationToken) => ({
        url: "/admin/registration-info",
        method: "GET",
        config: {
          params: {
            registrationToken
          }
        }
      }),
      transformResponse(res) {
        return res.data;
      }
    }),
    registerAdmin: builder.mutation({
      query: (body) => ({
        method: "POST",
        url: "/admin/register-admin",
        data: body
      }),
      transformResponse(res) {
        return res.data;
      }
    }),
    registerUser: builder.mutation({
      query: (body) => ({
        method: "POST",
        url: "/admin/register",
        data: body
      }),
      transformResponse(res) {
        return res.data;
      }
    }),
    forgotPassword: builder.mutation({
      query: (body) => ({
        url: "/admin/forgot-password",
        method: "POST",
        data: body
      })
    }),
    isSSOLocked: builder.query({
      query: () => ({
        url: "/admin/providers/isSSOLocked",
        method: "GET"
      }),
      transformResponse(res) {
        return res.data;
      }
    }),
    getProviders: builder.query({
      query: () => ({
        url: "/admin/providers",
        method: "GET"
      })
    }),
    getProviderOptions: builder.query({
      query: () => ({
        url: "/admin/providers/options",
        method: "GET"
      }),
      transformResponse(res) {
        return res.data;
      },
      providesTags: [
        "ProvidersOptions"
      ]
    }),
    updateProviderOptions: builder.mutation({
      query: (body) => ({
        url: "/admin/providers/options",
        method: "PUT",
        data: body
      }),
      transformResponse(res) {
        return res.data;
      },
      invalidatesTags: [
        "ProvidersOptions"
      ]
    })
  }),
  overrideExisting: false
});
var { useCheckPermissionsQuery, useLazyCheckPermissionsQuery, useGetMeQuery, useLoginMutation, useAccessTokenExchangeMutation, useLogoutMutation, useUpdateMeMutation, useResetPasswordMutation, useRegisterAdminMutation, useRegisterUserMutation, useGetRegistrationInfoQuery, useForgotPasswordMutation, useGetMyPermissionsQuery, useIsSSOLockedQuery, useGetProvidersQuery, useGetProviderOptionsQuery, useUpdateProviderOptionsMutation } = authService;

// node_modules/@strapi/admin/dist/admin/admin/src/features/Auth.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React = __toESM(require_react(), 1);

// node_modules/@strapi/admin/dist/admin/admin/src/utils/deviceId.mjs
var fallbackUUIDv4 = () => {
  const bytes = crypto.getRandomValues(new Uint8Array(16));
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const hex = [
    ...bytes
  ].map((b) => b.toString(16).padStart(2, "0"));
  return [
    hex.slice(0, 4).join(""),
    hex.slice(4, 6).join(""),
    hex.slice(6, 8).join(""),
    hex.slice(8, 10).join(""),
    hex.slice(10, 16).join("")
  ].join("-");
};
var getOrCreateDeviceId = () => {
  const storageKey = "strapi.admin.deviceId";
  const existing = window.localStorage.getItem(storageKey);
  if (existing) {
    return existing;
  }
  const generated = typeof (crypto == null ? void 0 : crypto.randomUUID) === "function" ? crypto.randomUUID() : fallbackUUIDv4();
  try {
    window.localStorage.setItem(storageKey, generated);
  } catch {
  }
  return generated;
};

// node_modules/@strapi/admin/dist/admin/admin/src/features/Auth.mjs
var [Provider, useAuth] = createContext("Auth");
var STORAGE_KEYS = {
  TOKEN: "jwtToken",
  STATUS: "isLoggedIn"
};
var AuthProvider = ({ children, _defaultPermissions = [], _disableRenewToken = false }) => {
  const dispatch = useTypedDispatch();
  const runRbacMiddleware = useStrapiApp("AuthProvider", (state) => state.rbac.run);
  const location = useLocation();
  const [{ rawQuery }] = useQueryParams();
  const locationRef = React.useRef(location);
  React.useEffect(() => {
    locationRef.current = location;
  }, [
    location
  ]);
  const token = useTypedSelector((state) => state.admin_app.token ?? null);
  const { data: user, isLoading: isLoadingUser } = useGetMeQuery(void 0, {
    /**
    * If there's no token, we don't try to fetch
    * the user data because it will fail.
    */
    skip: !token
  });
  const { data: userPermissions = _defaultPermissions, refetch, isUninitialized, isLoading: isLoadingPermissions } = useGetMyPermissionsQuery(void 0, {
    skip: !token
  });
  const navigate = useNavigate();
  const [loginMutation] = useLoginMutation();
  const [logoutMutation] = useLogoutMutation();
  const clearStateAndLogout = React.useCallback(() => {
    dispatch(adminApi.util.resetApiState());
    dispatch(logout());
    navigate("/auth/login");
  }, [
    dispatch,
    navigate
  ]);
  React.useEffect(() => {
    if (user) {
      if (user.preferedLanguage) {
        dispatch(setLocale(user.preferedLanguage));
      }
    }
  }, [
    dispatch,
    user
  ]);
  React.useEffect(() => {
    const handleUserStorageChange = (event) => {
      if (event.key === STORAGE_KEYS.STATUS && event.newValue === null) {
        clearStateAndLogout();
      }
    };
    window.addEventListener("storage", handleUserStorageChange);
    return () => {
      window.removeEventListener("storage", handleUserStorageChange);
    };
  });
  const login$1 = React.useCallback(async ({ rememberMe, ...body }) => {
    const res = await loginMutation({
      ...body,
      deviceId: getOrCreateDeviceId(),
      rememberMe
    });
    if ("data" in res) {
      const { token: token2 } = res.data;
      dispatch(login({
        token: token2,
        persist: rememberMe
      }));
    }
    return res;
  }, [
    dispatch,
    loginMutation
  ]);
  const logout$1 = React.useCallback(async () => {
    await logoutMutation({
      deviceId: getOrCreateDeviceId()
    });
    clearStateAndLogout();
  }, [
    clearStateAndLogout,
    logoutMutation
  ]);
  const refetchPermissions = React.useCallback(async () => {
    if (!isUninitialized) {
      await refetch();
    }
  }, [
    isUninitialized,
    refetch
  ]);
  const [checkPermissions] = useLazyCheckPermissionsQuery();
  const checkUserHasPermissions = React.useCallback(async (permissions, passedPermissions, rawQueryContext) => {
    if (!permissions || permissions.length === 0) {
      return [
        {
          action: "",
          subject: ""
        }
      ];
    }
    const actualUserPermissions = passedPermissions ?? userPermissions;
    const matchingPermissions = actualUserPermissions.filter((permission) => permissions.findIndex((perm) => perm.action === permission.action && // Only check the subject if it's provided
    (perm.subject == void 0 || perm.subject === permission.subject)) >= 0);
    const middlewaredPermissions = await runRbacMiddleware({
      user,
      permissions: userPermissions,
      pathname: locationRef.current.pathname,
      search: (rawQueryContext || rawQuery).split("?")[1] ?? ""
    }, matchingPermissions);
    const shouldCheckConditions = middlewaredPermissions.some((perm) => Array.isArray(perm.conditions) && perm.conditions.length > 0);
    if (!shouldCheckConditions) {
      return middlewaredPermissions;
    }
    const { data, error } = await checkPermissions({
      permissions: middlewaredPermissions.map((perm) => ({
        action: perm.action,
        subject: perm.subject
      }))
    });
    if (error) {
      throw error;
    } else {
      return middlewaredPermissions.filter((_, index) => (data == null ? void 0 : data.data[index]) === true);
    }
  }, [
    checkPermissions,
    rawQuery,
    runRbacMiddleware,
    user,
    userPermissions
  ]);
  const isLoading = isLoadingUser || isLoadingPermissions;
  return (0, import_jsx_runtime.jsx)(Provider, {
    token,
    user,
    login: login$1,
    logout: logout$1,
    permissions: userPermissions,
    checkUserHasPermissions,
    refetchPermissions,
    isLoading,
    children
  });
};

export {
  StrapiAppProvider,
  useStrapiApp,
  useQueryParams,
  useCheckPermissionsQuery,
  useUpdateMeMutation,
  useResetPasswordMutation,
  useRegisterAdminMutation,
  useRegisterUserMutation,
  useGetRegistrationInfoQuery,
  useForgotPasswordMutation,
  useIsSSOLockedQuery,
  useGetProvidersQuery,
  useGetProviderOptionsQuery,
  useUpdateProviderOptionsMutation,
  getOrCreateDeviceId,
  useAuth,
  AuthProvider
};
//# sourceMappingURL=chunk-OZMR6ZG7.js.map
