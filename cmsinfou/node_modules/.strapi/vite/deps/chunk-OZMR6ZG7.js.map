{
  "version": 3,
  "sources": ["../../../@strapi/admin/admin/src/features/StrapiApp.tsx", "../../../@strapi/admin/admin/src/hooks/useQueryParams.ts", "../../../@strapi/admin/admin/src/services/auth.ts", "../../../@strapi/admin/admin/src/utils/deviceId.ts", "../../../@strapi/admin/admin/src/features/Auth.tsx"],
  "sourcesContent": ["import { createContext } from '../components/Context';\nimport { RBAC } from '../core/apis/rbac';\nimport { Router } from '../core/apis/router';\n\nimport type { StrapiApp } from '../StrapiApp';\n\n/* -------------------------------------------------------------------------------------------------\n * StrapiApp\n * -----------------------------------------------------------------------------------------------*/\ninterface StrapiAppContextValue\n  extends Pick<\n      StrapiApp,\n      | 'customFields'\n      | 'getPlugin'\n      | 'getAdminInjectedComponents'\n      | 'plugins'\n      | 'runHookParallel'\n      | 'runHookSeries'\n      | 'widgets'\n    >,\n    Pick<Router, 'menu' | 'settings'> {\n  components: StrapiApp['library']['components'];\n  fields: StrapiApp['library']['fields'];\n  rbac: RBAC;\n  runHookWaterfall: <TData>(\n    name: Parameters<StrapiApp['runHookWaterfall']>[0],\n    initialValue: TData\n  ) => TData;\n}\n\nconst [StrapiAppProvider, useStrapiApp] = createContext<StrapiAppContextValue>('StrapiApp');\n\nexport { StrapiAppProvider, useStrapiApp };\nexport type { StrapiAppContextValue };\n", "import { useCallback, useMemo } from 'react';\n\nimport { parse, stringify } from 'qs';\nimport { useNavigate, useLocation } from 'react-router-dom';\n\nconst useSearch = () => {\n  const { search } = useLocation();\n\n  return useMemo(() => search, [search]);\n};\n\nconst useQueryParams = <TQuery extends object>(initialParams?: TQuery) => {\n  const search = useSearch();\n  const navigate = useNavigate();\n\n  const query = useMemo(() => {\n    // TODO: investigate why sometimes we're getting the search with a leading `?` and sometimes not.\n    const searchQuery = search.startsWith('?') ? search.slice(1) : search;\n    if (!search && initialParams) {\n      return initialParams;\n    }\n\n    return { ...initialParams, ...parse(searchQuery) } as TQuery;\n  }, [search, initialParams]);\n\n  const setQuery = useCallback(\n    (nextParams: TQuery, method: 'push' | 'remove' = 'push', replace = false) => {\n      let nextQuery = { ...query };\n\n      if (method === 'remove') {\n        Object.keys(nextParams).forEach((key) => {\n          if (Object.prototype.hasOwnProperty.call(nextQuery, key)) {\n            // @ts-expect-error â€“ this is fine, if you want to fix it, please do.\n            delete nextQuery[key];\n          }\n        });\n      } else {\n        nextQuery = { ...query, ...nextParams };\n      }\n\n      navigate({ search: stringify(nextQuery, { encode: false }) }, { replace });\n    },\n    [navigate, query]\n  );\n\n  return [{ query, rawQuery: search }, setQuery] as const;\n};\n\nexport { useQueryParams };\n", "import { ProvidersOptions } from '../../../shared/contracts/admin';\nimport {\n  type AccessTokenExchange,\n  type Login,\n  type ResetPassword,\n  type RegisterAdmin,\n  type Register,\n  type RegistrationInfo,\n  ForgotPassword,\n} from '../../../shared/contracts/authentication';\nimport { Check } from '../../../shared/contracts/permissions';\nimport { GetProviders, IsSSOLocked } from '../../../shared/contracts/providers';\nimport { type GetOwnPermissions, type GetMe, type UpdateMe } from '../../../shared/contracts/users';\n\nimport { adminApi } from './api';\n\nconst authService = adminApi\n  .enhanceEndpoints({\n    addTagTypes: ['User', 'Me', 'ProvidersOptions'],\n  })\n  .injectEndpoints({\n    endpoints: (builder) => ({\n      /**\n       * ME\n       */\n      getMe: builder.query<GetMe.Response['data'], void>({\n        query: () => ({\n          method: 'GET',\n          url: '/admin/users/me',\n        }),\n        transformResponse(res: GetMe.Response) {\n          return res.data;\n        },\n        providesTags: (res) => (res ? ['Me', { type: 'User', id: res.id }] : ['Me']),\n      }),\n      getMyPermissions: builder.query<GetOwnPermissions.Response['data'], void>({\n        query: () => ({\n          method: 'GET',\n          url: '/admin/users/me/permissions',\n        }),\n        transformResponse(res: GetOwnPermissions.Response) {\n          return res.data;\n        },\n      }),\n      updateMe: builder.mutation<UpdateMe.Response['data'], UpdateMe.Request['body']>({\n        query: (body) => ({\n          method: 'PUT',\n          url: '/admin/users/me',\n          data: body,\n        }),\n        transformResponse(res: UpdateMe.Response) {\n          return res.data;\n        },\n        invalidatesTags: ['Me'],\n      }),\n      /**\n       * Permissions\n       */\n      checkPermissions: builder.query<Check.Response, Check.Request['body']>({\n        query: (permissions) => ({\n          method: 'POST',\n          url: '/admin/permissions/check',\n          data: permissions,\n        }),\n      }),\n      /**\n       * Auth methods\n       */\n      login: builder.mutation<Login.Response['data'], Login.Request['body']>({\n        query: (body) => ({\n          method: 'POST',\n          url: '/admin/login',\n          data: body,\n        }),\n        transformResponse(res: Login.Response) {\n          return res.data;\n        },\n        invalidatesTags: ['Me'],\n      }),\n      logout: builder.mutation<void, { deviceId?: string } | void>({\n        query: (body) => ({\n          method: 'POST',\n          url: '/admin/logout',\n          data: body,\n        }),\n      }),\n      resetPassword: builder.mutation<\n        ResetPassword.Response['data'],\n        ResetPassword.Request['body']\n      >({\n        query: (body) => ({\n          method: 'POST',\n          url: '/admin/reset-password',\n          data: body,\n        }),\n        transformResponse(res: ResetPassword.Response) {\n          return res.data;\n        },\n      }),\n      accessTokenExchange: builder.mutation<\n        AccessTokenExchange.Response['data'],\n        AccessTokenExchange.Request['body']\n      >({\n        query: (body) => ({\n          method: 'POST',\n          url: '/admin/access-token',\n          data: body,\n        }),\n        transformResponse(res: AccessTokenExchange.Response) {\n          return res.data;\n        },\n      }),\n      getRegistrationInfo: builder.query<\n        RegistrationInfo.Response['data'],\n        RegistrationInfo.Request['query']['registrationToken']\n      >({\n        query: (registrationToken) => ({\n          url: '/admin/registration-info',\n          method: 'GET',\n          config: {\n            params: {\n              registrationToken,\n            },\n          },\n        }),\n        transformResponse(res: RegistrationInfo.Response) {\n          return res.data;\n        },\n      }),\n      registerAdmin: builder.mutation<\n        RegisterAdmin.Response['data'],\n        RegisterAdmin.Request['body']\n      >({\n        query: (body) => ({\n          method: 'POST',\n          url: '/admin/register-admin',\n          data: body,\n        }),\n        transformResponse(res: RegisterAdmin.Response) {\n          return res.data;\n        },\n      }),\n      registerUser: builder.mutation<Register.Response['data'], Register.Request['body']>({\n        query: (body) => ({\n          method: 'POST',\n          url: '/admin/register',\n          data: body,\n        }),\n        transformResponse(res: Register.Response) {\n          return res.data;\n        },\n      }),\n      forgotPassword: builder.mutation<ForgotPassword.Response, ForgotPassword.Request['body']>({\n        query: (body) => ({\n          url: '/admin/forgot-password',\n          method: 'POST',\n          data: body,\n        }),\n      }),\n      isSSOLocked: builder.query<IsSSOLocked.Response['data'], void>({\n        query: () => ({\n          url: '/admin/providers/isSSOLocked',\n          method: 'GET',\n        }),\n        transformResponse(res: IsSSOLocked.Response) {\n          return res.data;\n        },\n      }),\n      getProviders: builder.query<GetProviders.Response, void>({\n        query: () => ({\n          url: '/admin/providers',\n          method: 'GET',\n        }),\n      }),\n      getProviderOptions: builder.query<ProvidersOptions.Response['data'], void>({\n        query: () => ({\n          url: '/admin/providers/options',\n          method: 'GET',\n        }),\n        transformResponse(res: ProvidersOptions.Response) {\n          return res.data;\n        },\n        providesTags: ['ProvidersOptions'],\n      }),\n      updateProviderOptions: builder.mutation<\n        ProvidersOptions.Response['data'],\n        ProvidersOptions.Request['body']\n      >({\n        query: (body) => ({\n          url: '/admin/providers/options',\n          method: 'PUT',\n          data: body,\n        }),\n        transformResponse(res: ProvidersOptions.Response) {\n          return res.data;\n        },\n        invalidatesTags: ['ProvidersOptions'],\n      }),\n    }),\n    overrideExisting: false,\n  });\n\nconst {\n  useCheckPermissionsQuery,\n  useLazyCheckPermissionsQuery,\n  useGetMeQuery,\n  useLoginMutation,\n  useAccessTokenExchangeMutation,\n  useLogoutMutation,\n  useUpdateMeMutation,\n  useResetPasswordMutation,\n  useRegisterAdminMutation,\n  useRegisterUserMutation,\n  useGetRegistrationInfoQuery,\n  useForgotPasswordMutation,\n  useGetMyPermissionsQuery,\n  useIsSSOLockedQuery,\n  useGetProvidersQuery,\n  useGetProviderOptionsQuery,\n  useUpdateProviderOptionsMutation,\n} = authService;\n\nexport {\n  useCheckPermissionsQuery,\n  useLazyCheckPermissionsQuery,\n  useGetMeQuery,\n  useLoginMutation,\n  useAccessTokenExchangeMutation,\n  useLogoutMutation,\n  useUpdateMeMutation,\n  useResetPasswordMutation,\n  useRegisterAdminMutation,\n  useRegisterUserMutation,\n  useGetRegistrationInfoQuery,\n  useForgotPasswordMutation,\n  useGetMyPermissionsQuery,\n  useIsSSOLockedQuery,\n  useGetProvidersQuery,\n  useGetProviderOptionsQuery,\n  useUpdateProviderOptionsMutation,\n};\n", "const fallbackUUIDv4 = (): string => {\n  const bytes = crypto.getRandomValues(new Uint8Array(16));\n\n  bytes[6] = (bytes[6] & 0x0f) | 0x40;\n  bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n  const hex = [...bytes].map((b) => b.toString(16).padStart(2, '0'));\n  return [\n    hex.slice(0, 4).join(''),\n    hex.slice(4, 6).join(''),\n    hex.slice(6, 8).join(''),\n    hex.slice(8, 10).join(''),\n    hex.slice(10, 16).join(''),\n  ].join('-');\n};\n\n/**\n * Returns a stable device identifier for session-based authentication flows.\n * Uses localStorage to persist a UUID between sessions on the same browser.\n */\nexport const getOrCreateDeviceId = (): string => {\n  const storageKey = 'strapi.admin.deviceId';\n\n  const existing = window.localStorage.getItem(storageKey);\n  if (existing) {\n    return existing;\n  }\n\n  // Use randomUUID in secure contexts, otherwise polyfill\n  const generated =\n    typeof crypto?.randomUUID === 'function' ? crypto.randomUUID() : fallbackUUIDv4();\n\n  try {\n    window.localStorage.setItem(storageKey, generated);\n  } catch {\n    // no-op\n  }\n\n  return generated;\n};\n", "import * as React from 'react';\n\nimport { useLocation, useNavigate } from 'react-router-dom';\n\nimport { Login } from '../../../shared/contracts/authentication';\nimport { createContext } from '../components/Context';\nimport { useTypedDispatch, useTypedSelector } from '../core/store/hooks';\nimport { useStrapiApp } from '../features/StrapiApp';\nimport { useQueryParams } from '../hooks/useQueryParams';\nimport { login as loginAction, logout as logoutAction, setLocale } from '../reducer';\nimport { adminApi } from '../services/api';\nimport {\n  useGetMeQuery,\n  useGetMyPermissionsQuery,\n  useLazyCheckPermissionsQuery,\n  useLoginMutation,\n  useLogoutMutation,\n} from '../services/auth';\nimport { getOrCreateDeviceId } from '../utils/deviceId';\n\nimport type {\n  Permission as PermissionContract,\n  SanitizedAdminUser,\n} from '../../../shared/contracts/shared';\n\ninterface Permission\n  extends Pick<PermissionContract, 'action' | 'subject'>,\n    Partial<Omit<PermissionContract, 'action' | 'subject'>> {}\n\ninterface User\n  extends Pick<SanitizedAdminUser, 'email' | 'firstname' | 'lastname' | 'username' | 'roles'>,\n    Partial<Omit<SanitizedAdminUser, 'email' | 'firstname' | 'lastname' | 'username' | 'roles'>> {}\n\ninterface AuthContextValue {\n  login: (\n    body: Login.Request['body'] & { rememberMe: boolean }\n  ) => Promise<Awaited<ReturnType<ReturnType<typeof useLoginMutation>[0]>>>;\n  logout: () => Promise<void>;\n  /**\n   * @alpha\n   * @description given a list of permissions, this function checks\n   * those against the current user's permissions or those passed as\n   * the second argument, if the user has those permissions the complete\n   * permission object form the API is returned. Therefore, if the list is\n   * empty, the user does not have any of those permissions.\n   */\n  checkUserHasPermissions: (\n    permissions?: Array<Pick<Permission, 'action'> & Partial<Omit<Permission, 'action'>>>,\n    passedPermissions?: Permission[],\n    rawQueryContext?: string\n  ) => Promise<Permission[]>;\n  isLoading: boolean;\n  permissions: Permission[];\n  refetchPermissions: () => Promise<void>;\n  token: string | null;\n  user?: User;\n}\n\nconst [Provider, useAuth] = createContext<AuthContextValue>('Auth');\n\ninterface AuthProviderProps {\n  children: React.ReactNode;\n  /**\n   * @internal could be removed at any time.\n   */\n  _defaultPermissions?: Permission[];\n\n  // NOTE: this is used for testing purposed only\n  _disableRenewToken?: boolean;\n}\n\nconst STORAGE_KEYS = {\n  TOKEN: 'jwtToken',\n  STATUS: 'isLoggedIn',\n};\n\nconst AuthProvider = ({\n  children,\n  _defaultPermissions = [],\n  _disableRenewToken = false,\n}: AuthProviderProps) => {\n  const dispatch = useTypedDispatch();\n  const runRbacMiddleware = useStrapiApp('AuthProvider', (state) => state.rbac.run);\n  const location = useLocation();\n  const [{ rawQuery }] = useQueryParams();\n\n  const locationRef = React.useRef(location);\n\n  // Update ref without causing re-render\n  React.useEffect(() => {\n    locationRef.current = location;\n  }, [location]);\n\n  const token = useTypedSelector((state) => state.admin_app.token ?? null);\n\n  const { data: user, isLoading: isLoadingUser } = useGetMeQuery(undefined, {\n    /**\n     * If there's no token, we don't try to fetch\n     * the user data because it will fail.\n     */\n    skip: !token,\n  });\n\n  const {\n    data: userPermissions = _defaultPermissions,\n    refetch,\n    isUninitialized,\n    isLoading: isLoadingPermissions,\n  } = useGetMyPermissionsQuery(undefined, {\n    skip: !token,\n  });\n\n  const navigate = useNavigate();\n\n  const [loginMutation] = useLoginMutation();\n  const [logoutMutation] = useLogoutMutation();\n\n  const clearStateAndLogout = React.useCallback(() => {\n    dispatch(adminApi.util.resetApiState());\n    dispatch(logoutAction());\n    navigate('/auth/login');\n  }, [dispatch, navigate]);\n\n  React.useEffect(() => {\n    if (user) {\n      if (user.preferedLanguage) {\n        dispatch(setLocale(user.preferedLanguage));\n      }\n    }\n  }, [dispatch, user]);\n\n  React.useEffect(() => {\n    /**\n     * This will log a user out of all tabs if they log out in one tab.\n     */\n    const handleUserStorageChange = (event: StorageEvent) => {\n      if (event.key === STORAGE_KEYS.STATUS && event.newValue === null) {\n        clearStateAndLogout();\n      }\n    };\n\n    window.addEventListener('storage', handleUserStorageChange);\n\n    return () => {\n      window.removeEventListener('storage', handleUserStorageChange);\n    };\n  });\n\n  const login = React.useCallback<AuthContextValue['login']>(\n    async ({ rememberMe, ...body }) => {\n      const res = await loginMutation({ ...body, deviceId: getOrCreateDeviceId(), rememberMe });\n\n      /**\n       * There will always be a `data` key in the response\n       * because if something fails, it will throw an error.\n       */\n      if ('data' in res) {\n        const { token } = res.data;\n\n        dispatch(\n          loginAction({\n            token,\n            persist: rememberMe,\n          })\n        );\n      }\n\n      return res;\n    },\n    [dispatch, loginMutation]\n  );\n\n  const logout = React.useCallback(async () => {\n    await logoutMutation({ deviceId: getOrCreateDeviceId() });\n    clearStateAndLogout();\n  }, [clearStateAndLogout, logoutMutation]);\n\n  const refetchPermissions = React.useCallback(async () => {\n    if (!isUninitialized) {\n      await refetch();\n    }\n  }, [isUninitialized, refetch]);\n\n  const [checkPermissions] = useLazyCheckPermissionsQuery();\n  const checkUserHasPermissions: AuthContextValue['checkUserHasPermissions'] = React.useCallback(\n    async (\n      permissions,\n      passedPermissions,\n      // TODO:\n      // Here we have parameterised checkUserHasPermissions in order to pass\n      // query context from elsewhere in the application.\n      // See packages/core/content-manager/admin/src/features/DocumentRBAC.tsx\n\n      // This is in order to calculate permissions on accurate query params.\n      // We should be able to rely on the query params in this provider\n      // If we need to pass additional context to the RBAC middleware\n      // we should define a better context type.\n      rawQueryContext\n    ) => {\n      /**\n       * If there's no permissions to check, then we allow it to\n       * pass to preserve existing behaviours.\n       *\n       * TODO: should we review this? it feels more dangerous than useful.\n       */\n      if (!permissions || permissions.length === 0) {\n        return [{ action: '', subject: '' }];\n      }\n\n      /**\n       * Given the provided permissions, return the permissions from either passedPermissions\n       * or userPermissions as this is expected to be the full permission entity.\n       */\n      const actualUserPermissions = passedPermissions ?? userPermissions;\n\n      const matchingPermissions = actualUserPermissions.filter(\n        (permission) =>\n          permissions.findIndex(\n            (perm) =>\n              perm.action === permission.action &&\n              // Only check the subject if it's provided\n              (perm.subject == undefined || perm.subject === permission.subject)\n          ) >= 0\n      );\n\n      const middlewaredPermissions = await runRbacMiddleware(\n        {\n          user,\n          permissions: userPermissions,\n          pathname: locationRef.current.pathname,\n          search: (rawQueryContext || rawQuery).split('?')[1] ?? '',\n        },\n        matchingPermissions\n      );\n\n      const shouldCheckConditions = middlewaredPermissions.some(\n        (perm) => Array.isArray(perm.conditions) && perm.conditions.length > 0\n      );\n\n      if (!shouldCheckConditions) {\n        return middlewaredPermissions;\n      }\n\n      const { data, error } = await checkPermissions({\n        permissions: middlewaredPermissions.map((perm) => ({\n          action: perm.action,\n          subject: perm.subject,\n        })),\n      });\n\n      if (error) {\n        throw error;\n      } else {\n        return middlewaredPermissions.filter((_, index) => data?.data[index] === true);\n      }\n    },\n    [checkPermissions, rawQuery, runRbacMiddleware, user, userPermissions]\n  );\n\n  const isLoading = isLoadingUser || isLoadingPermissions;\n\n  return (\n    <Provider\n      token={token}\n      user={user}\n      login={login}\n      logout={logout}\n      permissions={userPermissions}\n      checkUserHasPermissions={checkUserHasPermissions}\n      refetchPermissions={refetchPermissions}\n      isLoading={isLoading}\n    >\n      {children}\n    </Provider>\n  );\n};\n\nexport { AuthProvider, useAuth, STORAGE_KEYS };\nexport type { AuthContextValue, Permission, User };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,IAAM,CAACA,mBAAmBC,YAAa,IAAGC,cAAqC,WAAA;;;;;ACzB/E,IAAMC,YAAY,MAAA;AAChB,QAAM,EAAEC,OAAM,IAAKC,YAAAA;AAEnB,aAAOC,sBAAQ,MAAMF,QAAQ;IAACA;EAAO,CAAA;AACvC;AAEA,IAAMG,iBAAiB,CAAwBC,kBAAAA;AAC7C,QAAMJ,SAASD,UAAAA;AACf,QAAMM,WAAWC,YAAAA;AAEjB,QAAMC,YAAQL,sBAAQ,MAAA;AAEpB,UAAMM,cAAcR,OAAOS,WAAW,GAAA,IAAOT,OAAOU,MAAM,CAAKV,IAAAA;AAC/D,QAAI,CAACA,UAAUI,eAAe;AAC5B,aAAOA;IACT;AAEA,WAAO;MAAE,GAAGA;MAAe,OAAGO,iBAAMH,WAAY;IAAC;KAChD;IAACR;IAAQI;EAAc,CAAA;AAE1B,QAAMQ,eAAWC,0BACf,CAACC,YAAoBC,SAA4B,QAAQC,UAAU,UAAK;AACtE,QAAIC,YAAY;MAAE,GAAGV;IAAM;AAE3B,QAAIQ,WAAW,UAAU;AACvBG,aAAOC,KAAKL,UAAYM,EAAAA,QAAQ,CAACC,QAAAA;AAC/B,YAAIH,OAAOI,UAAUC,eAAeC,KAAKP,WAAWI,GAAM,GAAA;AAExD,iBAAOJ,UAAUI,GAAI;QACvB;MACF,CAAA;WACK;AACLJ,kBAAY;QAAE,GAAGV;QAAO,GAAGO;MAAW;IACxC;AAEAT,aAAS;MAAEL,YAAQyB,qBAAUR,WAAW;QAAES,QAAQ;MAAM,CAAA;OAAM;MAAEV;IAAQ,CAAA;KAE1E;IAACX;IAAUE;EAAM,CAAA;AAGnB,SAAO;IAAC;MAAEA;MAAOoB,UAAU3B;IAAO;IAAGY;EAAS;AAChD;;;AC9BA,IAAMgB,cAAcC,SACjBC,iBAAiB;EAChBC,aAAa;IAAC;IAAQ;IAAM;EAAmB;AACjD,CAAA,EACCC,gBAAgB;EACfC,WAAW,CAACC,aAAa;;;;IAIvBC,OAAOD,QAAQE,MAAoC;MACjDA,OAAO,OAAO;QACZC,QAAQ;QACRC,KAAK;;MAEPC,kBAAkBC,KAAmB;AACnC,eAAOA,IAAIC;MACb;MACAC,cAAc,CAACF,QAASA,MAAM;QAAC;QAAM;UAAEG,MAAM;UAAQC,IAAIJ,IAAII;QAAG;UAAK;QAAC;MAAK;IAC7E,CAAA;IACAC,kBAAkBX,QAAQE,MAAgD;MACxEA,OAAO,OAAO;QACZC,QAAQ;QACRC,KAAK;;MAEPC,kBAAkBC,KAA+B;AAC/C,eAAOA,IAAIC;MACb;IACF,CAAA;IACAK,UAAUZ,QAAQa,SAA8D;MAC9EX,OAAO,CAACY,UAAU;QAChBX,QAAQ;QACRC,KAAK;QACLG,MAAMO;;MAERT,kBAAkBC,KAAsB;AACtC,eAAOA,IAAIC;MACb;MACAQ,iBAAiB;QAAC;MAAK;IACzB,CAAA;;;;IAIAC,kBAAkBhB,QAAQE,MAA6C;MACrEA,OAAO,CAACe,iBAAiB;QACvBd,QAAQ;QACRC,KAAK;QACLG,MAAMU;;IAEV,CAAA;;;;IAIAC,OAAOlB,QAAQa,SAAwD;MACrEX,OAAO,CAACY,UAAU;QAChBX,QAAQ;QACRC,KAAK;QACLG,MAAMO;;MAERT,kBAAkBC,KAAmB;AACnC,eAAOA,IAAIC;MACb;MACAQ,iBAAiB;QAAC;MAAK;IACzB,CAAA;IACAI,QAAQnB,QAAQa,SAA6C;MAC3DX,OAAO,CAACY,UAAU;QAChBX,QAAQ;QACRC,KAAK;QACLG,MAAMO;;IAEV,CAAA;IACAM,eAAepB,QAAQa,SAGrB;MACAX,OAAO,CAACY,UAAU;QAChBX,QAAQ;QACRC,KAAK;QACLG,MAAMO;;MAERT,kBAAkBC,KAA2B;AAC3C,eAAOA,IAAIC;MACb;IACF,CAAA;IACAc,qBAAqBrB,QAAQa,SAG3B;MACAX,OAAO,CAACY,UAAU;QAChBX,QAAQ;QACRC,KAAK;QACLG,MAAMO;;MAERT,kBAAkBC,KAAiC;AACjD,eAAOA,IAAIC;MACb;IACF,CAAA;IACAe,qBAAqBtB,QAAQE,MAG3B;MACAA,OAAO,CAACqB,uBAAuB;QAC7BnB,KAAK;QACLD,QAAQ;QACRqB,QAAQ;UACNC,QAAQ;YACNF;UACF;QACF;;MAEFlB,kBAAkBC,KAA8B;AAC9C,eAAOA,IAAIC;MACb;IACF,CAAA;IACAmB,eAAe1B,QAAQa,SAGrB;MACAX,OAAO,CAACY,UAAU;QAChBX,QAAQ;QACRC,KAAK;QACLG,MAAMO;;MAERT,kBAAkBC,KAA2B;AAC3C,eAAOA,IAAIC;MACb;IACF,CAAA;IACAoB,cAAc3B,QAAQa,SAA8D;MAClFX,OAAO,CAACY,UAAU;QAChBX,QAAQ;QACRC,KAAK;QACLG,MAAMO;;MAERT,kBAAkBC,KAAsB;AACtC,eAAOA,IAAIC;MACb;IACF,CAAA;IACAqB,gBAAgB5B,QAAQa,SAAkE;MACxFX,OAAO,CAACY,UAAU;QAChBV,KAAK;QACLD,QAAQ;QACRI,MAAMO;;IAEV,CAAA;IACAe,aAAa7B,QAAQE,MAA0C;MAC7DA,OAAO,OAAO;QACZE,KAAK;QACLD,QAAQ;;MAEVE,kBAAkBC,KAAyB;AACzC,eAAOA,IAAIC;MACb;IACF,CAAA;IACAuB,cAAc9B,QAAQE,MAAmC;MACvDA,OAAO,OAAO;QACZE,KAAK;QACLD,QAAQ;;IAEZ,CAAA;IACA4B,oBAAoB/B,QAAQE,MAA+C;MACzEA,OAAO,OAAO;QACZE,KAAK;QACLD,QAAQ;;MAEVE,kBAAkBC,KAA8B;AAC9C,eAAOA,IAAIC;MACb;MACAC,cAAc;QAAC;MAAmB;IACpC,CAAA;IACAwB,uBAAuBhC,QAAQa,SAG7B;MACAX,OAAO,CAACY,UAAU;QAChBV,KAAK;QACLD,QAAQ;QACRI,MAAMO;;MAERT,kBAAkBC,KAA8B;AAC9C,eAAOA,IAAIC;MACb;MACAQ,iBAAiB;QAAC;MAAmB;IACvC,CAAA;;EAEFkB,kBAAkB;AACpB,CAAA;AAEF,IAAM,EACJC,0BACAC,8BACAC,eACAC,kBACAC,gCACAC,mBACAC,qBACAC,0BACAC,0BACAC,yBACAC,6BACAC,2BACAC,0BACAC,qBACAC,sBACAC,4BACAC,iCAAgC,IAC9BxD;;;;;;;AC5NJ,IAAMyD,iBAAiB,MAAA;AACrB,QAAMC,QAAQC,OAAOC,gBAAgB,IAAIC,WAAW,EAAA,CAAA;AAEpDH,QAAM,CAAA,IAAMA,MAAM,CAAA,IAAK,KAAQ;AAC/BA,QAAM,CAAA,IAAMA,MAAM,CAAA,IAAK,KAAQ;AAE/B,QAAMI,MAAM;IAAIJ,GAAAA;IAAOK,IAAI,CAACC,MAAMA,EAAEC,SAAS,EAAA,EAAIC,SAAS,GAAG,GAAA,CAAA;AAC7D,SAAO;IACLJ,IAAIK,MAAM,GAAG,CAAA,EAAGC,KAAK,EAAA;IACrBN,IAAIK,MAAM,GAAG,CAAA,EAAGC,KAAK,EAAA;IACrBN,IAAIK,MAAM,GAAG,CAAA,EAAGC,KAAK,EAAA;IACrBN,IAAIK,MAAM,GAAG,EAAA,EAAIC,KAAK,EAAA;IACtBN,IAAIK,MAAM,IAAI,EAAA,EAAIC,KAAK,EAAA;EACxB,EAACA,KAAK,GAAA;AACT;IAMaC,sBAAsB,MAAA;AACjC,QAAMC,aAAa;AAEnB,QAAMC,WAAWC,OAAOC,aAAaC,QAAQJ,UAAAA;AAC7C,MAAIC,UAAU;AACZ,WAAOA;EACT;AAGA,QAAMI,YACJ,QAAOhB,iCAAQiB,gBAAe,aAAajB,OAAOiB,WAAU,IAAKnB,eAAAA;AAEnE,MAAI;AACFe,WAAOC,aAAaI,QAAQP,YAAYK,SAAAA;EAC1C,QAAQ;EAER;AAEA,SAAOA;AACT;;;ACmBA,IAAM,CAACG,UAAUC,OAAQ,IAAGC,cAAgC,MAAA;AAa5D,IAAMC,eAAe;EACnBC,OAAO;EACPC,QAAQ;AACV;AAEMC,IAAAA,eAAe,CAAC,EACpBC,UACAC,sBAAsB,CAAA,GACtBC,qBAAqB,MAAK,MACR;AAClB,QAAMC,WAAWC,iBAAAA;AACjB,QAAMC,oBAAoBC,aAAa,gBAAgB,CAACC,UAAUA,MAAMC,KAAKC,GAAG;AAChF,QAAMC,WAAWC,YAAAA;AACjB,QAAM,CAAC,EAAEC,SAAQ,CAAE,IAAIC,eAAAA;AAEvB,QAAMC,cAAoBC,aAAOL,QAAAA;AAGjCM,EAAMC,gBAAU,MAAA;AACdH,gBAAYI,UAAUR;KACrB;IAACA;EAAS,CAAA;AAEb,QAAMS,QAAQC,iBAAiB,CAACb,UAAUA,MAAMc,UAAUF,SAAS,IAAA;AAEnE,QAAM,EAAEG,MAAMC,MAAMC,WAAWC,cAAa,IAAKC,cAAcC,QAAW;;;;;IAKxEC,MAAM,CAACT;EACT,CAAA;AAEA,QAAM,EACJG,MAAMO,kBAAkB5B,qBACxB6B,SACAC,iBACAP,WAAWQ,qBAAoB,IAC7BC,yBAAyBN,QAAW;IACtCC,MAAM,CAACT;EACT,CAAA;AAEA,QAAMe,WAAWC,YAAAA;AAEjB,QAAM,CAACC,aAAAA,IAAiBC,iBAAAA;AACxB,QAAM,CAACC,cAAAA,IAAkBC,kBAAAA;AAEzB,QAAMC,sBAA4BC,kBAAY,MAAA;AAC5CtC,aAASuC,SAASC,KAAKC,cAAa,CAAA;AACpCzC,aAAS0C,OAAAA,CAAAA;AACTX,aAAS,aAAA;KACR;IAAC/B;IAAU+B;EAAS,CAAA;AAEvBlB,EAAMC,gBAAU,MAAA;AACd,QAAIM,MAAM;AACR,UAAIA,KAAKuB,kBAAkB;AACzB3C,iBAAS4C,UAAUxB,KAAKuB,gBAAgB,CAAA;MAC1C;IACF;KACC;IAAC3C;IAAUoB;EAAK,CAAA;AAEnBP,EAAMC,gBAAU,MAAA;AAId,UAAM+B,0BAA0B,CAACC,UAAAA;AAC/B,UAAIA,MAAMC,QAAQtD,aAAaE,UAAUmD,MAAME,aAAa,MAAM;AAChEX,4BAAAA;MACF;IACF;AAEAY,WAAOC,iBAAiB,WAAWL,uBAAAA;AAEnC,WAAO,MAAA;AACLI,aAAOE,oBAAoB,WAAWN,uBAAAA;IACxC;EACF,CAAA;AAEA,QAAMO,UAAcd,kBAClB,OAAO,EAAEe,YAAY,GAAGC,KAAM,MAAA;AAC5B,UAAMC,MAAM,MAAMtB,cAAc;MAAE,GAAGqB;MAAME,UAAUC,oBAAAA;MAAuBJ;IAAW,CAAA;AAMvF,QAAI,UAAUE,KAAK;AACjB,YAAM,EAAEvC,OAAAA,OAAK,IAAKuC,IAAIpC;AAEtBnB,eACE0D,MAAY;QACV1C,OAAAA;QACA2C,SAASN;MACX,CAAA,CAAA;IAEJ;AAEA,WAAOE;KAET;IAACvD;IAAUiC;EAAc,CAAA;AAG3B,QAAM2B,WAAetB,kBAAY,YAAA;AAC/B,UAAMH,eAAe;MAAEqB,UAAUC,oBAAAA;IAAsB,CAAA;AACvDpB,wBAAAA;KACC;IAACA;IAAqBF;EAAe,CAAA;AAExC,QAAM0B,qBAA2BvB,kBAAY,YAAA;AAC3C,QAAI,CAACV,iBAAiB;AACpB,YAAMD,QAAAA;IACR;KACC;IAACC;IAAiBD;EAAQ,CAAA;AAE7B,QAAM,CAACmC,gBAAAA,IAAoBC,6BAAAA;AAC3B,QAAMC,0BAA6E1B,kBACjF,OACE2B,aACAC,mBAUAC,oBAAAA;AAQA,QAAI,CAACF,eAAeA,YAAYG,WAAW,GAAG;AAC5C,aAAO;QAAC;UAAEC,QAAQ;UAAIC,SAAS;QAAG;MAAE;IACtC;AAMA,UAAMC,wBAAwBL,qBAAqBxC;AAEnD,UAAM8C,sBAAsBD,sBAAsBE,OAChD,CAACC,eACCT,YAAYU,UACV,CAACC,SACCA,KAAKP,WAAWK,WAAWL;KAE1BO,KAAKN,WAAW9C,UAAaoD,KAAKN,YAAYI,WAAWJ,QACzD,KAAA,CAAA;AAGT,UAAMO,yBAAyB,MAAM3E,kBACnC;MACEkB;MACA6C,aAAavC;MACboD,UAAUnE,YAAYI,QAAQ+D;MAC9BC,SAASZ,mBAAmB1D,UAAUuE,MAAM,GAAA,EAAK,CAAA,KAAM;OAEzDR,mBAAAA;AAGF,UAAMS,wBAAwBJ,uBAAuBK,KACnD,CAACN,SAASO,MAAMC,QAAQR,KAAKS,UAAU,KAAKT,KAAKS,WAAWjB,SAAS,CAAA;AAGvE,QAAI,CAACa,uBAAuB;AAC1B,aAAOJ;IACT;AAEA,UAAM,EAAE1D,MAAMmE,MAAK,IAAK,MAAMxB,iBAAiB;MAC7CG,aAAaY,uBAAuBU,IAAI,CAACX,UAAU;QACjDP,QAAQO,KAAKP;QACbC,SAASM,KAAKN;QAChB;IACF,CAAA;AAEA,QAAIgB,OAAO;AACT,YAAMA;WACD;AACL,aAAOT,uBAAuBJ,OAAO,CAACe,GAAGC,WAAUtE,6BAAMA,KAAKsE,YAAW,IAAA;IAC3E;KAEF;IAAC3B;IAAkBrD;IAAUP;IAAmBkB;IAAMM;EAAgB,CAAA;AAGxE,QAAML,YAAYC,iBAAiBO;AAEnC,aACE6D,wBAACpG,UAAAA;IACC0B;IACAI;IACAgC,OAAOA;IACPQ,QAAQA;IACRK,aAAavC;IACbsC;IACAH;IACAxC;IAECxB;;AAGP;",
  "names": ["StrapiAppProvider", "useStrapiApp", "createContext", "useSearch", "search", "useLocation", "useMemo", "useQueryParams", "initialParams", "navigate", "useNavigate", "query", "searchQuery", "startsWith", "slice", "parse", "setQuery", "useCallback", "nextParams", "method", "replace", "nextQuery", "Object", "keys", "forEach", "key", "prototype", "hasOwnProperty", "call", "stringify", "encode", "rawQuery", "authService", "adminApi", "enhanceEndpoints", "addTagTypes", "injectEndpoints", "endpoints", "builder", "getMe", "query", "method", "url", "transformResponse", "res", "data", "providesTags", "type", "id", "getMyPermissions", "updateMe", "mutation", "body", "invalidatesTags", "checkPermissions", "permissions", "login", "logout", "resetPassword", "accessTokenExchange", "getRegistrationInfo", "registrationToken", "config", "params", "registerAdmin", "registerUser", "forgotPassword", "isSSOLocked", "getProviders", "getProviderOptions", "updateProviderOptions", "overrideExisting", "useCheckPermissionsQuery", "useLazyCheckPermissionsQuery", "useGetMeQuery", "useLoginMutation", "useAccessTokenExchangeMutation", "useLogoutMutation", "useUpdateMeMutation", "useResetPasswordMutation", "useRegisterAdminMutation", "useRegisterUserMutation", "useGetRegistrationInfoQuery", "useForgotPasswordMutation", "useGetMyPermissionsQuery", "useIsSSOLockedQuery", "useGetProvidersQuery", "useGetProviderOptionsQuery", "useUpdateProviderOptionsMutation", "fallbackUUIDv4", "bytes", "crypto", "getRandomValues", "Uint8Array", "hex", "map", "b", "toString", "padStart", "slice", "join", "getOrCreateDeviceId", "storageKey", "existing", "window", "localStorage", "getItem", "generated", "randomUUID", "setItem", "Provider", "useAuth", "createContext", "STORAGE_KEYS", "TOKEN", "STATUS", "AuthProvider", "children", "_defaultPermissions", "_disableRenewToken", "dispatch", "useTypedDispatch", "runRbacMiddleware", "useStrapiApp", "state", "rbac", "run", "location", "useLocation", "rawQuery", "useQueryParams", "locationRef", "useRef", "React", "useEffect", "current", "token", "useTypedSelector", "admin_app", "data", "user", "isLoading", "isLoadingUser", "useGetMeQuery", "undefined", "skip", "userPermissions", "refetch", "isUninitialized", "isLoadingPermissions", "useGetMyPermissionsQuery", "navigate", "useNavigate", "loginMutation", "useLoginMutation", "logoutMutation", "useLogoutMutation", "clearStateAndLogout", "useCallback", "adminApi", "util", "resetApiState", "logoutAction", "preferedLanguage", "setLocale", "handleUserStorageChange", "event", "key", "newValue", "window", "addEventListener", "removeEventListener", "login", "rememberMe", "body", "res", "deviceId", "getOrCreateDeviceId", "loginAction", "persist", "logout", "refetchPermissions", "checkPermissions", "useLazyCheckPermissionsQuery", "checkUserHasPermissions", "permissions", "passedPermissions", "rawQueryContext", "length", "action", "subject", "actualUserPermissions", "matchingPermissions", "filter", "permission", "findIndex", "perm", "middlewaredPermissions", "pathname", "search", "split", "shouldCheckConditions", "some", "Array", "isArray", "conditions", "error", "map", "_", "index", "_jsx"]
}
