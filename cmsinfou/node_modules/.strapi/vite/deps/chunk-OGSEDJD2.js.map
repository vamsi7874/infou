{
  "version": 3,
  "sources": ["../../../@strapi/admin/admin/src/utils/users.ts"],
  "sourcesContent": ["import type { User } from '../features/Auth';\n\n/* -------------------------------------------------------------------------------------------------\n * getDisplayName\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Retrieves the display name of an admin panel user\n */\nconst getDisplayName = ({ firstname, lastname, username, email }: Partial<User> = {}): string => {\n  if (username) {\n    return username;\n  }\n\n  // firstname is not required if the user is created with a username\n  if (firstname) {\n    return `${firstname} ${lastname ?? ''}`.trim();\n  }\n\n  return email ?? '';\n};\n\n/* -------------------------------------------------------------------------------------------------\n * getInitials\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Retrieves the initials of the user (based on their firstname / lastname or their display name)\n */\nconst getInitials = (user: Partial<User> = {}): string => {\n  return user?.firstname && user?.lastname\n    ? `${user.firstname.substring(0, 1)}${user.lastname.substring(0, 1)}`\n    : getDisplayName(user)\n        .split(' ')\n        .map((name) => name.substring(0, 1))\n        .join('')\n        .substring(0, 1)\n        .toUpperCase();\n};\n\n/* -------------------------------------------------------------------------------------------------\n * hashAdminUserEmail\n * -----------------------------------------------------------------------------------------------*/\n\nconst hashAdminUserEmail = async (payload?: User) => {\n  if (!payload || !payload.email) {\n    return null;\n  }\n\n  try {\n    return await digestMessage(payload.email);\n  } catch (error) {\n    return null;\n  }\n};\n\nconst bufferToHex = (buffer: ArrayBuffer) => {\n  return [...new Uint8Array(buffer)].map((b) => b.toString(16).padStart(2, '0')).join('');\n};\nconst digestMessage = async (message: string) => {\n  const msgUint8 = new TextEncoder().encode(message);\n  const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);\n\n  return bufferToHex(hashBuffer);\n};\n\nexport { getDisplayName, getInitials, hashAdminUserEmail };\n"],
  "mappings": ";AASMA,IAAAA,iBAAiB,CAAC,EAAEC,WAAWC,UAAUC,UAAUC,MAAK,IAAoB,CAAA,MAAE;AAClF,MAAID,UAAU;AACZ,WAAOA;EACT;AAGA,MAAIF,WAAW;AACb,WAAO,GAAGA,SAAU,IAAGC,YAAY,EAAA,GAAKG,KAAI;EAC9C;AAEA,SAAOD,SAAS;AAClB;AASME,IAAAA,cAAc,CAACC,OAAsB,CAAA,MAAE;AAC3C,UAAOA,6BAAMN,eAAaM,6BAAML,YAC5B,GAAGK,KAAKN,UAAUO,UAAU,GAAG,CAAA,CAAA,GAAKD,KAAKL,SAASM,UAAU,GAAG,CAAG,CAAA,KAClER,eAAeO,IAAAA,EACZE,MAAM,GAAA,EACNC,IAAI,CAACC,SAASA,KAAKH,UAAU,GAAG,CAAA,CAAA,EAChCI,KAAK,EAAA,EACLJ,UAAU,GAAG,CAAA,EACbK,YAAW;AACpB;AAMA,IAAMC,qBAAqB,OAAOC,YAAAA;AAChC,MAAI,CAACA,WAAW,CAACA,QAAQX,OAAO;AAC9B,WAAO;EACT;AAEA,MAAI;AACF,WAAO,MAAMY,cAAcD,QAAQX,KAAK;EAC1C,SAASa,OAAO;AACd,WAAO;EACT;AACF;AAEA,IAAMC,cAAc,CAACC,WAAAA;AACnB,SAAO;IAAI,GAAA,IAAIC,WAAWD,MAAAA;EAAQ,EAACT,IAAI,CAACW,MAAMA,EAAEC,SAAS,EAAA,EAAIC,SAAS,GAAG,GAAA,CAAA,EAAMX,KAAK,EAAA;AACtF;AACA,IAAMI,gBAAgB,OAAOQ,YAAAA;AAC3B,QAAMC,WAAW,IAAIC,YAAcC,EAAAA,OAAOH,OAAAA;AAC1C,QAAMI,aAAa,MAAMC,OAAOC,OAAOC,OAAO,WAAWN,QAAAA;AAEzD,SAAOP,YAAYU,UAAAA;AACrB;",
  "names": ["getDisplayName", "firstname", "lastname", "username", "email", "trim", "getInitials", "user", "substring", "split", "map", "name", "join", "toUpperCase", "hashAdminUserEmail", "payload", "digestMessage", "error", "bufferToHex", "buffer", "Uint8Array", "b", "toString", "padStart", "message", "msgUint8", "TextEncoder", "encode", "hashBuffer", "crypto", "subtle", "digest"]
}
